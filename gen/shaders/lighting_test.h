#pragma once
// autogenerated from GLSL, do not edit
#include <glm/glm.hpp>
#include "../../src/graphics/OpenGLContext.h"
#include "../../src/graphics/commands.h"
#include "../../src/graphics/Shader.h"
#include "../../src/util.h"
#include "../../src/loader/shaders.h"
#include "../../src/graphics/texturing.h"
namespace pipelines { namespace lighting_test {
struct VertexShader {
    string key = "/home/chris/code/game_engine/res/shaders/lighting/all.vert";
    string getKey() const;
    shared_ptr<Shader> build(OpenGLContext& context);
};
struct FragmentShader {
    string key = "/home/chris/code/game_engine/res/shaders/lighting/all.frag";
    string getKey() const;
    shared_ptr<Shader> build(OpenGLContext& context);
};
class Shaders {
    ShaderCache& cache;
public:
    Shaders(ShaderCache& cache);
    Shaders(ShaderCache* cache);
    ShaderStages getStages() const;
};
struct alignas(16) MatrixBlock {
    glsl::mat4 viewMatrix;
    glsl::mat4 projectionMatrix;
    alignas(16) glm::vec3 cameraPosition;
};
struct alignas(16) Material {
    alignas(16) glm::vec3 materialSpecularColor;
    float materialShininess;
};
struct alignas(16) Light {
    alignas(16) glm::vec3 position;
    float range;
    alignas(16) glm::vec3 color;
    float ambientCoefficient;
    alignas(16) glm::vec3 direction;
    float innerConeAngle;
    alignas(16) glm::vec3 attenuation;
    float outerConeAngle;
};
struct alignas(16) LightingBlock {
    Light allLights[1];
};
struct VertexInput {
    glm::vec2 texCoord;
    glm::vec3 position;
    glm::vec3 normal;
    glm::vec3 tangent;
};
struct InstanceInput {
    glsl::mat4 modelMatrix;
    glsl::mat3 normalMatrix;
};
struct VertexBindingPipelineState;
struct VertexBindingCreateInfo;
struct VertexBindings {
    const VertexBufferBinding<VertexInput> perVertex;
    const VertexBufferBinding<InstanceInput> perInstance;
    using CreateInfo = VertexBindingCreateInfo;
    using PipelineState = VertexBindingPipelineState;
};
struct VertexBindingPipelineState {
    void bindAll(const VertexBindings& bindings, BoundVertexArrayGuard& guard, OpenGLContext& context);
};
struct VertexBindingCreateInfo {
    VertexBindingPipelineState init(VertexArray& array, OpenGLContext& context);
};
struct ResourceBindingPipelineState;
struct ResourceBindingCreateInfo;
struct ResourceBindings {
    const BufferView<MatrixBlock> matrixBlock;
    const BufferView<Material> material;
    const BufferView<LightingBlock> lightingBlock;
    const TextureBinding<Texture2d> materialTexture;
    const TextureBinding<Texture2d> normalMap;
    using CreateInfo = ResourceBindingCreateInfo;
    using PipelineState = ResourceBindingPipelineState;
};
struct ResourceBindingPipelineState {
    void bindAll(const ResourceBindings& bindings, OpenGLContext& context);
};
struct ResourceBindingCreateInfo {
    ResourceBindingPipelineState init();
};
using Pipeline = GraphicsPipeline<VertexBindings, ResourceBindings>;
using Create = GraphicsPipelineCreateInfo<VertexBindings, ResourceBindings, Shaders>;
using DrawCmd = DrawCommand<VertexBindings, ResourceBindings>;
}}